/**
 * KXML contains functions and classes for reading, parsing, and writing XML
 * documents.
 *
 * Copyright:	(c) 2009 William K. Moore, III (nyphbl8d (at) gmail (dot) com, opticron on freenode)
 * Authors:	William K. Moore, III
 * License:	Boost Software License - Version 1.0 - August 17th, 2003

 Permission is hereby granted, free of charge, to any person or organization
 obtaining a copy of the software and accompanying documentation covered by
 this license (the "Software") to use, reproduce, display, distribute,
 execute, and transmit the Software, and to prepare derivative works of the
 Software, and to permit third-parties to whom the Software is furnished to
 do so, all subject to the following:

 The copyright notices in the Software and this entire statement, including
 the above license grant, this restriction and the following disclaimer,
 must be included in all copies of the Software, in whole or in part, and
 all derivative works of the Software, unless such copies or derivative
 works are solely in the form of machine-executable object code generated by
 a source language processor.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 DEALINGS IN THE SOFTWARE.

 * Standards:	Attempts to conform to XML 1.0 Specification
 */

// TODO xpath
//	support full paths for both sides of the inequality (start with one side...)
//	support node cdata matching
//	support * for nodes and attributes
//	support [#] (note that this is a 1-based index
//	support [@*] to catch all nodes with attributes
//	support [not(@*)] to catch all nodes with no attributes
//	support [last()] with math (yes, it's lame)? (last is $-1)

module libdxml2.xml;
import std.conv:to;
import std.string:split,replace,isNumeric,toStringz;
import std.ascii:isspace=isWhite;
import core.stdc.stdio:printf;
import std.regex;
R regrep(R)(R input, R pattern, R delegate(R) translator) {
	R tmpdel(Captures!(R,size_t) m) {
		return translator(m.hit);
	}
	return std.regex.replace!(tmpdel)(input, regex(pattern, "g"));
}
import std.stdio;
private void logline(string str) {
	// 64 bit DMD doesn't like calling varargs very much.
	std.stdio.writef("%s", str);
}

import core.exception:RangeError;
import std.range:isInputRange,isForwardRange,isBidirectionalRange,empty,front,popFront,save,back,popBack,popFrontN,popBackN,walkLength;
import std.uni:isWhite,toLower;

/* custom version of strip that uses the below */
R strip(R)(R tostrip) {
	return stripLeft(stripRight(tostrip));
}

unittest {
	logline("string strip test\n");
	string a = " asdf  a  ";
	assert("asdf  a" == strip(a));
	logline("custring strip test\n");
	assert(cast(custring)"asdf  a" == strip(cast(custring)a));
}
/* custom version of stripLeft that relies only on isInputRange capabilities */
R stripLeft(R)(R tostrip) if (isInputRange!R) {
	while (!tostrip.empty && isWhite(tostrip.front)) {
		tostrip.popFront();
	}
	return tostrip;
}

unittest {
	logline("string stripLeft test\n");
	string a = " asdf  a  ";
	assert("asdf  a  " == stripLeft(a));
	logline("custring stripLeft test\n");
	assert(cast(custring)"asdf  a  " == stripLeft(cast(custring)a));
}
/* custom version of stripRight that relies only on isBidirectionalRange capabilities */
R stripRight(R)(R tostrip) if (isBidirectionalRange!R) {
	while(!tostrip.empty() && isWhite(tostrip.back)) {
		tostrip.popBack();
	}
	return tostrip;
}

unittest {
	logline("string stripRight test\n");
	string a = " asdf  a  ";
	assert(" asdf  a" == stripRight(a));
	logline("custring stripRight test\n");
	assert(cast(custring)" asdf  a" == stripRight(cast(custring)a));
}
/* custom icmp using generic cmp w/ predicate */
import std.algorithm:cmp,equal,startsWith,endsWith,countUntil;
int doCompare(C)(C a, C b) {return toLower(cast(dchar)a) < toLower(cast(dchar)b);}
int icmp(R1,R2)(R1 s1, R2 s2) {
	return cmp!(doCompare)(s1,s2);
}

unittest {
	string a = "asdf";
	string b = "AsDf";
	string c = "asdfg";
	logline("string icmp test\n");
	assert(!.icmp(a,b));
	assert(.icmp(a,c));
	logline("custring icmp test\n");
	assert(!.icmp(cast(custring)a,cast(custring)b));
	assert(.icmp(cast(custring)a,cast(custring)c));
}

/* This is UGLY.  This is a combination of hasSlicing and hasLength with out the isNarrowString reliance.
 * It was necessitated by the fact that this was ported from D1 where narrow strings were all the rage. */
template isGoodType(R)
{
	enum bool isGoodType = is(typeof(
	{
		R r = void;
		static assert(isBidirectionalRange!(typeof(r)));
		//static assert(isStringAssignable!(typeof(r)));
		static assert(isSelfAssignable!(typeof(r)));
		static assert(hasStringCast!(typeof(r)));
		static assert(hasConcat!(typeof(r)));
	}));
}

template hasStringCast(R)
{
	enum bool hasStringCast = is(typeof(
	{
		R r = void;
		string s = to!string(r);
	}));
}

template hasConcat(R)
{
	enum bool hasConcat = is(typeof(
	{
		R r = void;
		r = r ~ r;
	}));
}

template isStringAssignable(R)
{
	enum bool isStringAssignable = is(typeof(
	{
		R r = void;
		string s = void;
		r = s;
	}));
}

template isSelfAssignable(R)
{
	enum bool isSelfAssignable = is(typeof(
	{
		R r = void;
		r = r;
	}));
}


/**
 * Read an entire string into a tree of XmlNodes.
 * This defaults to stripping all whitespace for a speed gain (less objects created), but can be forced to preserve whitespace using the second parameter.
 * Example:
 * --------------------------------
 * string xmlstring = "<message responseID=\"1234abcd\" text=\"weather 12345\" type=\"message\"><flags>triggered</flags><flags>targeted</flags></message>";
 * XmlNode xml = xmlstring.readDocument();
 * xmlstring = xml.toXml;
 * // ensure that the string doesn't mutate after a second reading, it shouldn't
 * debug(xml)logline("kxml.xml unit test\n");
 * assert(xmlstring.readDocument().toXml == xmlstring);
 * debug(xpath)logline("kxml.xml XPath unit test\n");
 * XmlNode[]searchlist = xml.parseXPath("message/flags");
 * assert(searchlist.length == 2 && searchlist[0].getName == "flags");
 * 
 * debug(xpath)logline("kxml.xml deep XPath unit test\n");
 * searchlist = xml.parseXPath("//message//flags");
 * assert(searchlist.length == 2 && searchlist[0].getName == "flags");
 * 
 * debug(xpath)logline("kxml.xml attribute match XPath unit test\n");
 * searchlist = xml.parseXPath("/message[@type=\"message\" and @responseID=\"1234abcd\"]/flags");
 * assert(searchlist.length == 2 && searchlist[0].getName == "flags");
 * searchlist = xml.parseXPath("message[@type=\"toaster\"]/flags");
 * assert(searchlist.length == 0);
 * --------------------------------
 * Returns: An XmlNode with no name that is the root of the document that was read.
 * Throws: XmlError on any parsing errors.
 */
auto readDocument(R)(R src, bool preserveWS=false)
if (isGoodType!R)
{
	auto pointcpy = src.save;
	auto root = new XmlNode!R();
	try {
		root.addChildren(src,preserveWS);
	} catch (XmlError e) {
		logline("Caught exception from input string:\n"~to!string(pointcpy)~"\n");
		throw e;
	}
	return root;
}

/// An exception thrown on an xml parsing error.
class XmlError : Exception {
	this(string msg) {
		super(msg);
	}
}

/// An exception thrown on an XPath parsing error.
class XPathError : Exception {
	this(string msg) {
		super(msg);
	}
}


/**
 * XmlNode represents a single xml node and has methods for modifying
 * attributes and adding children.  All methods that make changes modify this
 * XmlNode rather than making a copy, unless otherwise noted.  Many methods
 * return a self reference to allow cascaded calls.
 * Example:
 * --------------------------------
 * // Create an XmlNode tree with attributes and cdata, and write it to a file.
 * node.addChild(new XmlNode("mynode").setAttribute("x", 50).
 *     addChild(new XmlNode("Waldo").addCData("Hello!"))).write("myfile.xml");
 * --------------------------------*/
class XmlNode(R=string) if (isGoodType!R)
{
	protected XmlDocument!R _docroot;
	protected R _name;
	protected R[R] _attributes;
	protected XmlNode!R[]      _children;



	static this(){}

	/// Construct an empty XmlNode.
	this(){}

	/// Construct and set the name of this XmlNode.
	this(R name) {
		_name = name;
	}

	/// Get the name of this XmlNode.
	R getName() {
		return _name;
	}

	/// Set the name of this XmlNode.
	void setName(R newName) {
		_name = newName;
	}

	/// Does this XmlNode have the specified attribute?
	bool hasAttribute(R name) {
		return (name in _attributes) !is null;
	}

	/// Get the specified attribute, or return null if the XmlNode doesn't have that attribute.
	R getAttribute(R name) {
		if (name in _attributes) {
			return xmlDecode(_attributes[name]);
		}
		return to!R("");
	}

	/// Return an array of all attributes (does a single pass of XML entity decoding like &quot; -> ").
	R[R] getAttributes() {
		R[R]tmp;
		// this is inefficient as it is run every time, but doesn't hurt parsing speed
		foreach(key;_attributes.keys) {
			tmp[key] = xmlDecode(_attributes[key]);
		}
		return tmp;
	}

	/// Set an attribute to a string value.
	/// The attribute is created if it doesn't exist.
	XmlNode!R setAttribute(R name, R value) {
		_attributes[name] = xmlEncode(value);
		return this;
	}

	/// Set an attribute to an integer value (stored internally as a string).
	/// The attribute is created if it doesn't exist.
	XmlNode!R setAttribute(R name, long value) {
		return setAttribute(name, to!R(to!string(value)));
	}

	/// Set an attribute to a float value (stored internally as a string).
	/// The attribute is created if it doesn't exist.
	XmlNode!R setAttribute(R name, float value) {
		return setAttribute(name, to!R(to!string(value)));
	}

	/// Remove the attribute with name.
	XmlNode!R removeAttribute(R name) {
		_attributes.remove(name);
		return this;
	}

	/// Add a child node.
	XmlNode!R addChild(XmlNode!R newNode) {
		// let's bump things by increments of 10 to make them more efficient
		if (_children.length+1%10==0) {
			_children.length = _children.length + 10;
			_children.length = _children.length - 10;
		}
		_children.length = _children.length + 1;
		_children[$-1] = newNode;
		return this;
	}

	/// Get all child nodes associated with this object.
	/// Returns: An raw, uncopied array of all child nodes.
	auto getChildren() {
		return _children;
	}

	/// Remove the child with the same reference as what was given.
	/// Returns: The number of children removed.
	size_t removeChild(XmlNode!R remove) {
		size_t len = _children.length;
		for (size_t i = 0;i<_children.length;i++) if (_children[i] is remove) {
			// we matched it, so remove it
			// don't return true yet, since we're removing all references to it, not just the first one
			_children = _children[0..i]~_children[i+1..$];
		}
		return len - _children.length;
	}

	/// Add a child Node of cdata (text).
	XmlNode!R addCData(R cdata) {
		auto cd = (_docroot?_docroot.allocCData:new CData!R);
		cd.setCData(cdata);
		addChild(cd);
		return this;
	}

	/// Check to see if this node is a CData node.
	final bool isCData() {
		if (cast(CData!R)this) return true;
		return false;
	}

	/// Check to see if this node is a XmlPI node.
	final bool isXmlPI() {
		if (cast(XmlPI!R)this) return true;
		return false;
	}

	/// Check to see if this node is a XmlComment node.
	final bool isXmlComment() {
		if (cast(XmlComment!R)this) return true;
		return false;
	}

	/// This function makes life easier for those looking to pull cdata from a tag, in the case of multiple nodes, it pulls all first level cdata nodes.
	R getCData() {
		R tmp;
		foreach(child;_children) if (child.isCData) {
			tmp = tmp ~ child.getCData(); 
		}
		return tmp;
	}

	/// This function resets the node to a default state
	void reset() {
		foreach(child;_children) {
			child.reset;
		}
		_children.length = 0;
		_attributes = null;
		_name = null;
		// put back in the pool of available XmlNode nodes if possible
		if (_docroot) {
			_docroot.xmlNodes.length = _docroot.xmlNodes.length + 1;
			_docroot.xmlNodes[$-1] = this;
		}
	}

	/// This function removes all child nodes from the current node
	auto removeChildren() {
		_children.length = 0;
		return this;
	}

	/// This function sets the cdata inside the current node as intelligently as possible (without allocation, hopefully)
	XmlNode!R setCData(R cdata) {
		if (_children.length == 1 && _children[0].isCData) {
			// since the only node is CData, just set the text and be done
			_children[0].setCData(cdata);
		} else {
			removeChildren;
			addCData(cdata);
		}
		return this;
	}

	/// This function gives you the inner xml as it would appear in the document.
	auto getInnerXML() {
		R tmp;
		foreach(child;_children) {
			tmp = tmp ~ child.toXml(); 
		}
		return tmp;
	}

	// internal function to generate opening tags
	R asOpenTag() {
		if (_name.empty) {
			return _name;
		}
		auto s = to!R("<") ~ _name ~ genAttrString();

		if (_children.length == 0) {
			s = s ~ to!R(" /"); // We want <blah /> if the node has no children.
		}
		s = s ~ to!R(">");

		return s;
	}

	// internal function used to generate the attribute list
	protected auto genAttrString() {
		R ret;
		foreach (keys,values;_attributes) {
			ret = ret ~ to!R(" ") ~ keys ~ to!R("=\"") ~ values ~ to!R("\"");
		}
		return ret;
	}

	// internal function to generate closing tags
	R asCloseTag() {
		if (_name.empty) {
			return _name;
		}
		if (!_children.length) return to!R(""); // don't need it.  Leaves close themselves via the <blah /> syntax.
		return to!R("</") ~ _name ~ to!R(">");
	}

	final protected bool isLeaf() {
		return !_children.length;
	}

	/// This function dumps the xml structure to a string with no newlines and no linefeeds to be output.
	R toXml() {
		auto tmp = asOpenTag();

		if (_children.length) {
			tmp = tmp ~ getInnerXML();
			tmp = tmp ~ asCloseTag();
		}
		return tmp;
	}

	/// This function dumps the xml structure in to pretty, tabbed format.
	R toPrettyXml(R indent) {
		R tmp;
		if (getName.length) tmp = indent~asOpenTag()~to!R("\n");
	
		if (_children.length) {
			for (int i = 0; i < _children.length; i++) {
				// these guys are supposed to do their own indentation
				tmp = tmp~_children[i].toPrettyXml(indent~to!R(getName.length?"	":""));
			}
			if (getName.length) tmp = tmp~indent~asCloseTag()~to!R("\n");
		}
		return tmp;
	}

	/// Add children from a string containing valid xml.
	void addChildren(R xsrc,bool preserveWS) {
		while (!xsrc.empty) {
			// there may be multiple tag trees or cdata elements
			parseNode(this,xsrc,preserveWS);
		}
	}

	/// Add array of nodes directly into this node as children.
	void addChildren(XmlNode!R[]newChildren) {
		// let's bump things by increments of 10 to make them more efficient
		if (_children.length+newChildren.length%10 < newChildren.length) {
			_children.length = _children.length + 10;
			_children.length = _children.length - 10;
		}
		_children.length = _children.length + newChildren.length;
		_children[$-newChildren.length..$] = newChildren[0..$];
	}

	// snag some text and lob it into a cdata node
	private void parseCData(XmlNode!R parent,ref R xsrc,bool preserveWS) {
		ptrdiff_t slice;
		R token = xsrc.save;
		slice = readUntil(xsrc, "<");
		popBackN(token, walkLength(token.save) - slice);
		// don't break xml whitespace specs unless requested
		if (!preserveWS) token = stripRight(token);
		popFrontN(xsrc, slice);
		debug(xml)logline("I found cdata text: "~to!string(token)~"\n");
		// DO NOT CHANGE THIS TO USE THE CONSTRUCTOR, BECAUSE THE CONSTRUCTOR IS FOR USER USE
		auto cd = (_docroot?_docroot.allocCData:new CData!R);
		cd._cdata = token;
		parent.addChild(cd);
	}

	// parse out a close tag and make sure it's the one we want
	private void parseCloseTag(XmlNode!R parent,ref R xsrc) {
		ptrdiff_t slice;
		xsrc.popFront();
		R token = xsrc.save;
		slice = readUntil(xsrc,">");
		popBackN(token, walkLength(token.save) - slice);
		token = strip(token);
		popFrontN(xsrc, slice);
		xsrc.popFront();
		debug(xml)logline("I found a closing tag:"~to!string(token)~"\n");
		if (icmp(token, parent.getName()) != 0) throw new XmlError("Wrong close tag: "~to!string(token)~" for parent tag "~to!string(parent.getName));
	}

	// rip off a xml processing instruction, like the ones that come at the beginning of xml documents
	private void parseXMLPI(XmlNode!R parent,ref R xsrc) {
		// rip off <?
		xsrc.popFront();
		xsrc = stripLeft(xsrc);
		// rip off name
		R name = getWSToken(xsrc);
		XmlPI!R newnode;
		if (endsWith(name, "?")) {
			// and we're at the end of the element
			name.popBack();
			newnode = (_docroot?_docroot.allocXmlPI:new XmlPI!R);
			newnode.setName(name);
			parent.addChild(newnode);
			return;
		}
		// rip off attributes while looking for ?>
		debug(xml)logline("Got a "~to!string(name)~" XML processing instruction\n");
		newnode = (_docroot?_docroot.allocXmlPI:new XmlPI!R);
		newnode.setName(name);
		xsrc = stripLeft(xsrc);
		while(walkLength(xsrc.save, 2) >= 2 && startsWith(xsrc, "?>")) {
			parseAttribute(newnode,xsrc);
		}
		// make sure that the ?> is there and rip it off
		if (!startsWith(xsrc, "?>")) throw new XmlError("Could not find the end to xml processing instruction "~to!string(name));
		popFrontN(xsrc, 2);
		parent.addChild(newnode);
	}

	// rip off an unparsed character data node
	private void parseUCData(XmlNode!R parent,ref R xsrc) {
		ptrdiff_t slice;
		popFrontN(xsrc, 7);
		R token = xsrc.save;
		slice = readUntil(xsrc,"]]>");
		popBackN(token, walkLength(token.save) - slice);
		popFrontN(xsrc, slice);
		popFrontN(xsrc, 3);
		debug(xml)logline("I found cdata text: "~to!string(token)~"\n");
		// DO NOT CHANGE THIS TO USE THE CONSTRUCTOR, BECAUSE THE CONSTRUCTOR IS FOR USER USE
		auto cd = (_docroot?_docroot.allocCData:new CData!R);
		cd._cdata = token;
		parent.addChild(cd);
	}

	// rip off a comment
	private void parseComment(XmlNode!R parent,ref R xsrc) {
		ptrdiff_t slice;
		popFrontN(xsrc, 2);
		R token = xsrc.save;
		slice = readUntil(xsrc,"-->");
		popBackN(token, walkLength(token.save) - slice);
		popFrontN(xsrc, slice);
		popFrontN(xsrc, 3);
		auto x = (_docroot?_docroot.allocXmlComment:new XmlComment!R);
		x._comment = token;
		parent.addChild(x);
	}

	// rip off a XML Instruction
	private void parseXMLInst(XmlNode!R parent,ref R xsrc) {
		ptrdiff_t slice;
		R token = xsrc.save;
		auto maxslice = walkLength(xsrc.save);
		slice = readUntil(xsrc,">");
		slice += ">".length;
		if (slice>maxslice) slice = maxslice;
		popBackN(token, maxslice - slice);
		popFrontN(xsrc, slice);
		// XXX we probably want to do something with these
	}

	// rip off a XML opening tag
	private void parseOpenTag(XmlNode!R parent,ref R xsrc,bool preserveWS) {
		// rip off name
		R name = getWSToken(xsrc);
		// rip off attributes while looking for ?>
		debug(xml)logline("Got a "~to!string(name)~" open tag\n");
		auto newnode = (_docroot?_docroot.allocXmlNode:new XmlNode!R);
		newnode.setName(name);
		xsrc = stripLeft(xsrc);
		while(!xsrc.empty && xsrc.front != '/' && xsrc.front != '>') {
			parseAttribute(newnode,xsrc);
		}
		// check for self-closing tag
		parent.addChild(newnode);
		if (xsrc.front == '/') {
			// strip off the / and go about business as normal
			xsrc.popFront();
			xsrc = stripLeft(xsrc);
			// check for >
			if (xsrc.empty || xsrc.front != '>') throw new XmlError("Unable to find end of "~to!string(name)~" tag");
			xsrc.popFront();
			xsrc = stripLeft(xsrc);
			debug(xml)logline("self-closing tag!\n");
			return;
		} 
		// check for >
		if (xsrc.empty || xsrc.front != '>') throw new XmlError("Unable to find end of "~to!string(name)~" tag");
		xsrc.popFront();
		// don't rape whitespace unless requested
		if (!preserveWS) xsrc = stripLeft(xsrc);
		// now that we've added all the attributes to the node, pass the rest of the string and the current node to the next node
		int ret;
		while (!xsrc.empty) {
			if ((ret = parseNode(newnode,xsrc,preserveWS)) == 1) {
				break;
			}
		}
		// make sure we found our closing tag
		// this is where we can get sloppy for stream parsing
		// throw a missing closing tag exception
		if (!ret) throw new XmlError("Missing end tag for "~to!string(name));
	}

	// returns everything after the first node TREE (a node can be text as well)
	private int parseNode(XmlNode!R parent,ref R xsrc,bool preserveWS) {
		// if it was just whitespace and no more text or tags, make sure that's covered
		int ret = 0;
		// this has been removed from normal code flow to be XML std compliant, preserve whitespace
		if (!preserveWS) xsrc = stripLeft(xsrc); 
		debug(xml)logline("Parsing text: "~to!string(xsrc)~"\n");
		if (xsrc.empty) {
			return 0;
		}
		R token;
		if (xsrc.front != '<') {
			parseCData(parent,xsrc,preserveWS);
			return 0;
		} 
		xsrc.popFront();
		
		// types of tags, gotta make sure we find the closing > (or ]]> in the case of ucdata)
		switch(xsrc.front) {
		default:
			// just a regular old tag
			parseOpenTag(parent,xsrc,preserveWS);
			break;
		case '/':
			// closing tag!
			parseCloseTag(parent,xsrc);
			ret = 1;
			break;
		case '?':
			// processing instruction!
			parseXMLPI(parent,xsrc);
			break;
		case '!':
			xsrc.popFront();
			xsrc = stripLeft(xsrc);
			// 10 is the magic number that allows for the empty cdata string [CDATA[]]>
			if (walkLength(xsrc.save, 10) >= 10 && startsWith(xsrc, "[CDATA[")) {
				// unparsed cdata!
				parseUCData(parent,xsrc);
				break;
			// make sure we parse out comments, minimum length for this is 7 (<!---->)
			} else if (walkLength(xsrc.save, 5) >= 5 && startsWith(xsrc, "--")) {
				parseComment(parent,xsrc);
				break;
			}
			// xml instruction is the default for this case
			parseXMLInst(parent,xsrc);
			break;
		}
		return ret;
	}

	// read data until the delimiter is found, return the index where the delimiter starts
	private ptrdiff_t readUntil(U)(R xsrc, U delim) {
		// XXX FIX ME NOW
		auto len = countUntil(xsrc, delim);
		if (len = -1) return walkLength(xsrc);
		return len;
	}

	// basically to get the name off of open tags
	private R getWSToken(ref R input) {
		input = stripLeft(input);
		int i;
		auto ret = input.save;
		for(i=0;!input.empty() && !isspace(input.front) && input.front != '>' && input.front != '/' && input.front != '<' && input.front != '=' && input.front != '!';i++,input.popFront()){}
		popBackN(ret, walkLength(ret.save) - i);
		if (ret.empty) {
			throw new XmlError("Unable to parse token at: "~to!string(input));
		}
		return ret;
	}

	// this code is now officially prettified
	private void parseAttribute (XmlNode!R xml,ref R attrstr) {
		auto ripName(ref R input) {
			int i;
			auto ret = input.save;
			for(i=0;!input.empty() && !isspace(input.front) && input.front != '=';i++,input.popFront()){}
			popBackN(ret, walkLength(ret.save) - i);
			return ret;
		}
		auto ripValue(ref R input) {
		        int x;
			auto quot = input.front;
			// rip off the starting quote
			input.popFront();
			// find the end of the string we want
			auto tmp = input.save;
		        for(x = 0;input.front != quot && !input.empty();x++,input.popFront()) {
		        }
		        popBackN(tmp, walkLength(tmp.save) - x);
			// leave off the quote
		        input.popFront();
		        return tmp;
		}

		// snag the name from the attribute string
		R value,name = ripName(attrstr);
		attrstr = stripLeft(attrstr);
		// check for = to make sure the attribute string is kosher
		if (attrstr.empty()) throw new XmlError("Unexpected end of attribute string near "~to!string(name));
		if (attrstr.front != '=') throw new XmlError("Missing = in attribute string with name "~to!string(name));
		// rip off =
		attrstr.popFront();
		attrstr = stripLeft(attrstr);
		if (!attrstr.empty) {
			if (attrstr.front == '"' || attrstr.front == '\'') {
				value = ripValue(attrstr);
			} else {
				throw new XmlError("Unquoted attribute value for "~to!string(xml.getName)~", starting at: "~to!string(attrstr));
			}
		} else {
			throw new XmlError("Unexpected end of input for attribute "~to!string(name)~" in node "~to!string(xml.getName));
		}
		debug(xml)logline("Got attr "~to!string(name)~" and value \""~to!string(value)~"\"\n");
		xml._attributes[name] = value;
		attrstr = stripLeft(attrstr);
	}

	/// Do an XPath search on this node and return all matching nodes.
	/// This function does not perform any modifications to the tree and so does not support XML mutation.
	XmlNode!R[] parseXPath(R xpath,bool caseSensitive = false) {
		// rip off the leading / if it's there and we're not looking for a deep path
		if (!isDeepPath(xpath) && !xpath.empty() && xpath.front == '/') xpath.popFront();
		debug(xpath)logline("Got xpath "~to!string(xpath)~" in node "~to!string(getName)~"\n");
		R truncxpath;
		auto nextnode = getNextNode(xpath,truncxpath);
		R predmatch;
		// XXX need to be able to split the attribute match off even when it doesn't have [] around it
		ptrdiff_t offset = countUntil(nextnode, "[");
		if (offset != -1) {
			// rip out attribute string
			predmatch = nextnode.save;
			popFrontN(predmatch, offset);
			popBackN(nextnode, walkLength(nextnode.save) - offset);
			debug(xpath)logline("Found predicate chunk: "~to!string(predmatch)~"\n");
		}
		debug(xpath)logline("Looking for "~to!string(nextnode)~"\n");
		XmlNode[]retarr;
		// search through the children to see if we have a direct match on the next node
		if (nextnode.empty) {
			// we were searching for nodes, and this is one
			debug(xpath)logline("Found a node we want! name is: "~to!string(getName)~"\n");
			retarr ~= this;
		} else if (nextnode.front == '@') {
			if (matchXPathPredicate(nextnode, caseSensitive)) {
				auto attr = getWSToken(nextnode);
				attr.popFront();
				retarr ~= new CData!R(getAttribute(attr));
			}
		} else foreach(child;getChildren) if (!child.isCData && !child.isXmlComment && !child.isXmlPI && child.matchXPathPredicate(predmatch,caseSensitive)) {
			if (nextnode.empty || (caseSensitive && equal(child.getName, nextnode)) || (!caseSensitive && !icmp(child.getName(), nextnode))) {
				// child that matches the search string, pass on the truncated string
				debug(xpath)logline("Sending "~to!string(truncxpath)~" to "~to!string(child.getName)~"\n");
				retarr ~= child.parseXPath(truncxpath,caseSensitive);
			}
		}
		// we aren't on us, but check to see if we're looking for a deep path, and delve in accordingly
		// currently this means, the entire tree could be traversed multiple times for a single query...eww
		// and the query // should generate a list of the entire tree, in the order the elements specifically appear
		if (isDeepPath(xpath)) foreach(child;getChildren) if (!child.isCData && !child.isXmlComment && !child.isXmlPI) {
			// throw the exact same xpath at each child
			retarr ~= child.parseXPath(xpath,caseSensitive);
		}
		return retarr;
	}

	private bool matchXPathPredicate(R predstr,bool caseSen) {
		debug(xpath)logline("matching predicate string "~to!string(predstr)~"\n");
		// strip off the encasing [] if it exists
		if (predstr.empty) {
			return true;
		}
		if (predstr.front == '[' && predstr.back == ']') {
			predstr.popFront();
			predstr.popBack();
		} else if (predstr.front == '[' || predstr.back == ']') {
			// this seems to be malformed
			throw new XPathError("got malformed predicate match "~to!string(predstr)~"\n");
		}
		// rip apart the xpath predicate assuming it's node and attribute matches
		R[]predlist;
		// basically, we're splitting on " and " and " or ", but while respecting []
		int bcount = 0, i = 0;
		ptrdiff_t lslice = 0;
		R tmpstr = predstr.save;
		for( dchar quote = '\0'; !tmpstr.empty(); ) {
			auto c = tmpstr.front;
			if( quote != '\0' ) {
				if( quote == c ) {
					quote = '\0';
				}
			} else if (c == '\'' || c == '"' ) {
				quote = c;
			} else if (c == '[') {
				bcount++;
			} else if (c == ']') {
				bcount--;
			} else if (bcount == 0 && c == ' ') {
				if (i != lslice) {
					auto tmp = predstr.save;
					popBackN(tmp, walkLength(tmp.save) - i);
					popFrontN(tmp, lslice);
					predlist ~= tmp;
				}
				lslice = i+1;
			}
			i++;
			tmpstr.popFront();
		}
		// tack the last one on
		auto tmp = predstr.save;
		popFrontN(tmp, lslice);
		predlist ~= tmp;
		// length must be odd, otherwise the string is jank
		if (!(predlist.length%2)) throw new XPathError("Encountered a janky predicate: "~to!string(predstr));
		// verify that odd numbers are "and" or "or"
		foreach (j,attr;predlist) if (j%2 && !equal(attr, "and") && !equal(attr, "or")) {
			throw new XPathError("Encountered consecutive terms not separated by \"and\" or \"or\" starting at: "~to!string(attr));
		} else if (!(j%2) && (equal(attr, "and") || equal(attr, "or"))) {
			throw new XPathError("Encountered consecutive joining terms (\"and\" or \"or\") in: "~to!string(predstr));
		}
		bool[]res;
		res.length = predlist.length;
		int numOrdTerms = 0;
		debug(xpath)foreach (pred;predlist) {
			logline("Term: "~to!string(pred)~"\n");
		}
		foreach (j,pred;predlist) if (!(j%2)) {
			debug(xpath)logline("matching on "~to!string(pred)~"\n");
			bool isattr   = false;		// is elem1 @attribute
			bool verbatim = false;		// is elem2 quoted string
			R elem1;			// Left of comparator
			R comparator;			// null, ">","<","=", ">=","<=","!="
			R elem2;			// right of comparator

			if (pred.front == '@') {
				isattr = true;
				pred.popFront();
			}
			// TODO XXX check elem1/elem2 is an XPath func()
			elem1 = getWSToken(pred);
			pred = stripLeft(pred);
			// if there is still data in pred, it's time to look for a comparison operator
			if (!pred.empty) {
				// figure out what comparison needs to be done
				auto secelem = pred.save;
				if (!secelem.empty()) secelem.popFront();
				if (!secelem.empty() && (pred.front == '<' || pred.front == '>' || pred.front == '!') && secelem.front == '=') {
					comparator = pred.save;
					popBackN(comparator, walkLength(comparator.save) - 2);
					popFrontN(pred, 2);
					pred = stripLeft(pred);
				} else if (pred.front == '<' || pred.front == '>' || pred.front == '=') {
					comparator = pred.save;
					popBackN(comparator, walkLength(comparator.save) - 1);
					pred.popFront();
					pred = stripLeft(pred);
				} else {
					throw new XPathError("Could not determine comparator at: "~to!string(pred));
				}
				secelem = pred.save;
				if (!secelem.empty()) secelem.popFront();
				if (secelem.empty() && !isNumeric(to!string([pred.front]))) { 
					throw new XPathError("Badly formed XPath query: Non-numeric comparands must be quoted ("~to!string(pred)~")");
				}
				// strip off quotes if necessary
				if (pred.back == '"' && pred.front == '"') {
					pred.popFront();
					pred.popBack();
					verbatim = true;
				} else if (pred.back == '"' || pred.front == '"') {
					throw new XPathError("Badly formed XPath query: Missing quote ("~to!string(pred)~")");
				}
			}
			elem2 = pred.save;
			// check to see if we're doing an attribute match
			// there should be NO zero-length strings this far in
			if ( isattr ) {
				if (!hasAttribute(elem1)) {
					debug(xpath)logline("could not find attr "~to!string(elem1)~"\n");
					res[j] = false;
					continue;
				}
				if( comparator.length == 0 ) {
					// Just check for existance
					res[j] = true;
					continue;
				}
				res[j] = compareXPathPredicate( elem1, comparator, elem2, getAttribute(elem1), caseSen );
			}
			else if (true) {
				// assume elem1 is a tag
				//if (!comparator.length || !elem2.length) throw new XPathError("Is this really an Error?");
				foreach(child;getChildren) { 
					if( child.isCData || child.isXmlComment || child.isXmlPI || child.getName != elem1 )
						continue;
				
					if( compareXPathPredicate( elem1, comparator, elem2, child.getCData, caseSen )) {
						res[j] = true;
						break;
					}
				}
			}				
			// XXX take care of other types of matches other than attribute matches
		} else if (equal(pred, "or")) {
			numOrdTerms++;
		}
		// collect "and" terms into "or" groups
		bool[]ordTerms;
		ordTerms.length = numOrdTerms + 1;
		ordTerms[0] = res[0];
		debug(xpath)logline("res[0]="~to!(string)(res[0])~"\n");
		numOrdTerms = 0; // we're using this as current position, now
		foreach (j,attr;predlist) if (j%2) {
			if (equal(attr, "and")) {
				debug(xpath)logline("combining anded terms on ord term "~to!(string)(numOrdTerms)~" and i="~to!(string)(j)~" with res.length="~to!(string)(res.length)~" and predlist.length="~to!(string)(predlist.length)~"\n");
				ordTerms[numOrdTerms] &= res[j+1];
				debug(xpath)logline("res["~to!(string)(j+1)~"]="~to!(string)(res[j+1])~"\n");
			} else if (equal(attr, "or")) {
				numOrdTerms++;
				ordTerms[numOrdTerms] = res[j+1];
			} else {
				throw new XPathError("Erm...nuh uh");
			}
		}
		// now that results have been determined, map them to a final result using "and" and "or"
		bool ret = false;
		foreach (val;ordTerms) ret |= val;
		debug(xpath)logline("Ended up with "~to!(string)(ret)~"\n");
		return ret;
	}

	private bool compareXPathPredicate( R elem1, R comparator, R elem2, R elem1value, bool caseSen )
	{
		if (!comparator.empty) {
			// make sure that if we pulled a comparator, there's something to compare on the other side
			if (elem2.empty) throw new XPathError("Got a comparator without anything to compare");
			bool lres,i1num = isNumeric(to!string(elem1value)),i2num = isNumeric(to!string(elem2));
			if (comparator.front == '<' || comparator.front == '>') {
				// Must be numeric
				if( !i2num )
					throw new XPathError("Badly formed XPath query: comparator '"~to!string(comparator)~"' requires a numeric operand Not ("~to!string(elem2)~")");
				if( !i1num ) {
					return false;
				}
			
				// get numeric equivalents
				double i1 = to!double(to!string(elem1value));
				double i2 = to!double(to!string(elem2));

				if (comparator.front == '<') {
					lres = i1 < i2;
				} else /*if (comparator.front == '>')*/ {
					lres = i1 > i2;
				}
				// check to see if equality is also called for
				if (comparator.back == '=') {
					lres |= (i1 == i2);
				}
			} else {
				bool neg = false;
				if (comparator.front == '!') neg = true;

				if( !i1num || !i2num ) {
					if ((!equal(elem1value, elem2) && caseSen) || (icmp(elem1value, elem2) != 0 && !caseSen)) {
						debug(xpath)logline("search value "~to!string(elem2)~" did not match attribute value "~to!string(elem1value)~"\n");
						lres = false;
					} else {
						lres = true;
					}
				} else {
					// get numeric equivalents
					double i1 = to!double(to!string(elem1value));
					double i2 = to!double(to!string(elem2));
					lres = (i1 == i2);
				}
				if (neg) lres = !lres;
			}
			return lres;
		}
		return false;
	}


	private bool isDeepPath(R xpath) {
		// check to see if we're currently searching a deep path
		auto secelem = xpath.save;
		if (!secelem.empty()) secelem.popFront();
		if (walkLength(xpath.save, 2) >= 2 && xpath.front == '/' && secelem.front == '/') {
			return true;
		}
		return false;
	}

	// this does not modify the incoming string, only pulls a slice out of it
	private auto getNextNode(R xpath,out R truncxpath) {
		if (isDeepPath(xpath)) popFrontN(xpath, 2);
		// dig through the pile of xpath, but make sure to respect attribute matches properly
		int contexts = 0, i = 0;
		R tmpxpath = xpath.save;
		while(!tmpxpath.empty()) {
			auto c = tmpxpath.front;
			if (c == '[') contexts++;
			if (c == ']') contexts--;
			if (c == '/' && !contexts) {
				// we've found the end of the current node
				truncxpath = xpath.save;
				popFrontN(truncxpath, i);
				popBackN(xpath, walkLength(xpath.save) - i);
				return xpath;
			}
			tmpxpath.popFront();
			i++;
		}
		// i'm not sure this can occur unless the string was blank to begin with...
		truncxpath = null;
		return xpath;
	}

	/// Index override for getting attributes.
	auto opIndex(R attr) {
		return getAttribute(attr);
	}

	/// Index override for getting children.
	auto opIndex(int childnum) {
		if (childnum < _children.length) return _children[childnum];
		return null;
	}

	/// Index override for setting attributes.
	auto opIndexAssign(R value, R name) {
		return setAttribute(name,value);
	}

	/// Index override for replacing children.
	auto opIndexAssign(XmlNode!R x,int childnum) {
		if (childnum > _children.length) throw new Exception("Child element assignment is outside of array bounds");
		_children[childnum] = x;
		return this;
	}

	override bool opEquals(Object o) {
		auto cmp = cast(XmlNode!R)o;
		if (cmp is null) {
			return false;
		}
		// quick check to make sure things are the same before we go deeper
		if (getName != cmp.getName) {
			return false;
		}
		if (getChildren != cmp.getChildren) {
			return false;
		}
		// compare attributes
		foreach(attrib,value;getAttributes) {
			if (!(attrib in cmp.getAttributes)) {
				return false;
			}
			if (value != cmp.getAttribute(attrib)) {
				return false;
			}
		}

		return true;
	}
}

/// A class specialization for CData nodes.
class CData(R=string) : XmlNode!R
{
	private R _cdata;

	/// Override the string constructor, assuming the data is coming from a user program, possibly with unescaped XML entities that need escaping.
	this(R cdata) {
		setCData(cdata);
	}

	this(){}

	/// Get CData string associated with this object.
	/// Returns: Parsed Character Data with decoded XML entities
	override R getCData() {
		return xmlDecode!R(_cdata);
	}

	/// This function assumes data is coming from user input, possibly with unescaped XML entities that need escaping.
	override CData!R setCData(R cdata) {
		_cdata = xmlEncode(cdata);
		return this;
	}

	/// This function resets the node to a default state
	override void reset() {
		// put back in the pool of available CData nodes if possible
		if (_docroot) {
			_docroot.cdataNodes.length = _docroot.cdataNodes.length + 1;
			_docroot.cdataNodes[$-1] = this;
		}
		_cdata = null;
	}

	/// This outputs escaped XML entities for use on the network or in a document.
	protected override R toXml() {
		return _cdata;
	}

	/// This outputs escaped XML entities for use on the network or in a document in pretty, tabbed format.
	protected override R toPrettyXml(R indent) { 
		return indent~toXml()~to!R("\n");
	}

	override R asCloseTag() { return to!R(""); }

	/// This throws an exception because CData nodes do not have names.
	override R getName() {
		throw new XmlError("CData nodes do not have names to get.");
	}

	/// This throws an exception because CData nodes do not have names.
	override void setName(R newName) {
		throw new XmlError("CData nodes do not have names to set.");
	}

	/// This throws an exception because CData nodes do not have attributes.
	override bool hasAttribute(R name) {
		throw new XmlError("CData nodes do not have attributes.");
	}

	/// This throws an exception because CData nodes do not have attributes.
	override R getAttribute(R name) {
		throw new XmlError("CData nodes do not have attributes to get.");
	}

	/// This throws an exception because CData nodes do not have attributes.
	override R[R] getAttributes() {
		throw new XmlError("CData nodes do not have attributes to get.");
	}

	/// This throws an exception because CData nodes do not have attributes.
	override XmlNode!R setAttribute(R name, R value) {
		throw new XmlError("CData nodes do not have attributes to set.");
	}

	/// This throws an exception because CData nodes do not have attributes.
	override XmlNode!R setAttribute(R name, long value) {
		throw new XmlError("CData nodes do not have attributes to set.");
	}

	/// This throws an exception because CData nodes do not have attributes.
	override XmlNode!R setAttribute(R name, float value) {
		throw new XmlError("CData nodes do not have attributes to set.");
	}

	/// This throws an exception because CData nodes do not have children.
	override XmlNode!R addChild(XmlNode!R newNode) {
		throw new XmlError("Cannot add a child node to CData.");
	}

	/// This throws an exception because CData nodes do not have children.
	override XmlNode!R addCData(R cdata) {
		throw new XmlError("Cannot add a child node to CData.");
	}

	override bool opEquals(Object o) {
		auto cmp = cast(CData!R)o;
		if (cmp is null) {
			return false;
		}
		if (getCData != cmp.getCData) {
			return false;
		}
		return true;
	}
}

/// A class specialization for XML instructions.
class XmlPI(R=string) : XmlNode!R {
	this(){}

	/// Override the constructor that takes a name so that it's accessible.
	this(R name) {
		super(name);
	}

	/// This node can't have children, and so can't have CData.
	/// Should this throw an exception?
	override R getCData() {
		return to!R("");
	}

	/// Override toXml for output to be used by parsers.
	override R toXml() {
		return asOpenTag();
	}

	/// This function resets the node to a default state
	override void reset() {
		// put back in the pool of available CData nodes if possible
		_name = null;
		_attributes = null;
		if (_docroot) {
			_docroot.xmlPINodes.length = _docroot.xmlPINodes.length + 1;
			_docroot.xmlPINodes[$-1] = this;
		}
	}

	/// Pretty print to be used by parsers.
	protected override R toPrettyXml(R indent = to!R("")) {
		return indent~asOpenTag()~to!R("\n");
	}

	// internal function to generate opening tags
	override R asOpenTag() {
		if (_name.empty) return to!R("");
		auto s = to!R("<?") ~ _name ~ genAttrString() ~ to!R("?>");
		return s;
	}

	// internal function to generate closing tags
	override R asCloseTag() { return to!R(""); }

	/// You can't add a child to something that can't have children.  There is no adoption in XML world.
	override XmlNode!R addChild(XmlNode!R newNode) {
		throw new XmlError("Cannot add a child node to XmlPI.");
	}

	/// You can't add a child to something that can't have children.  There is no adoption in XML world.
	/// Especially for red-headed stepchildren CData nodes.
	override XmlNode!R addCData(R cdata) {
		throw new XmlError("Cannot add a child node to XmlPI.");
	}

	override bool opEquals(Object o) {
		auto cmp = cast(XmlPI!R)o;
		if (cmp is null) {
			return false;
		}
		if (getName != cmp.getName || getAttributes != cmp.getAttributes) {
			return false;
		}
		return true;
	}
}

/// A class specialization for XML comments.
class XmlComment(R=string) : XmlNode!R {
	R _comment;
	this(){}
	this(R comment) {
		_comment = comment;
		super(to!R(""));
	}

	/// This node can't have children, and so can't have CData.
	/// Should this throw an exception?
	override R getCData() {
		return to!R("");
	}

	/// This function resets the node to a default state
	override void reset() {
		// put back in the pool of available XmlComment nodes if possible
		_comment = null;
		if (_docroot) {
			_docroot.xmlCommentNodes.length = _docroot.xmlCommentNodes.length + 1;
			_docroot.xmlCommentNodes[$-1] = this;
		}
	}

	/// Override toXml for output to be used by parsers.
	override R toXml() {
		return asOpenTag();
	}

	/// Pretty print to be used by parsers.
	protected override R toPrettyXml(R indent = to!R("")) {
		return indent~asOpenTag()~to!R("\n");
	}

	// internal function to generate opening tags
	protected override R asOpenTag() {
		if (_name.empty) {
			return to!R("");
		}
		return to!R("<!--") ~ _comment  ~ to!R("-->");
	}

	// internal function to generate closing tags
	override R asCloseTag() { return to!R(""); }

	/// The members of Project Mayhem have no name... (this throws an exception)
	override R getName() {
		throw new XmlError("Comment nodes do not have names to get.");
	}

	/// Ditto. (this throws an exception)
	override void setName(R newName) {
		throw new XmlError("Comment nodes do not have names to set.");
	}

	/// These events can not be attributed to space monkeys. (this throws an exception)
	override bool hasAttribute(R name) {
		throw new XmlError("Comment nodes do not have attributes.");
	}

	/// Ditto. (this throws an exception)
	override R getAttribute(R name) {
		throw new XmlError("Comment nodes do not have attributes to get.");
	}

	/// Ditto. (this throws an exception)
	override R[R] getAttributes() {
		throw new XmlError("Comment nodes do not have attributes to get.");
	}

	/// Ditto. (this throws an exception)
	override XmlNode!R setAttribute(R name, R value) {
		throw new XmlError("Comment nodes do not have attributes to set.");
	}

	/// Ditto. (this throws an exception)
	override XmlNode!R setAttribute(R name, long value) {
		throw new XmlError("Comment nodes do not have attributes to set.");
	}

	/// Ditto. (this throws an exception)
	override XmlNode!R setAttribute(R name, float value) {
		throw new XmlError("Comment nodes do not have attributes to set.");
	}

	/// Comments don't have children. (this throws an exception)
	override XmlNode!R addChild(XmlNode!R newNode) {
		throw new XmlError("Cannot add a child node to comment.");
	}

	/// Ditto. (this throws an exception)
	override XmlNode!R addCData(R cdata) {
		throw new XmlError("Cannot add a child node to comment.");
	}

	override bool opEquals(Object o) {
		auto cmp = cast(XmlComment!R)o;
		if (cmp is null) {
			return false;
		}
		if (_comment != cmp._comment) {
			return false;
		}
		return true;
	}
}

/** This is the encapsulating class for xml documents that allows reuse of nodes
  * so as to not allocate ALL THE TIME if you find it convenient to reuse the structure
  * Example:
  *--------------------------
  * string xmlstring = "<message responseID=\"1234abcd\" text=\"weather 12345\" type=\"message\"><flags>triggered</flags><flags>targeted</flags></message>";
  * // here we have the creation of an XmlDocument using the static opCall
  * auto newdoc = XmlDocument(xmlstring);
  * // reset rips apart the node tree to be reused
  * newdoc.reset;
  * // so reuse the XmlDocument that already has allocated nodes
  * newdoc.parse(xmlstring);
  * // here we have the creation of a secondary with a constructor
  * newdoc = new XmlDocument();
  * newdoc.parse(xmlstring);
  * // and again with the parse constructor
  * newdoc = new XmlDocument(xmlstring);
  * // XmlDocuments act like XmlNodes without attributes or names, so you can add children
  * newdoc.addCData("A long long time ago, in a galaxy far far away...");
  *--------------------------
  */
public int prealloc = 50;
///ditto
class XmlDocument(R=string) : XmlNode!R {
	// this should inherit the reset and toXml that we want
	protected XmlNode!R[]xmlNodes;
	protected XmlComment!R[]xmlCommentNodes;
	protected CData!R[]cdataNodes;
	protected XmlPI!R[]xmlPINodes;
	this() {
		_docroot = this;
		// allocate some XmlNodes to kick us off
		xmlNodes.length = prealloc;
		XmlNode!R tmp;
		foreach(ref node;xmlNodes) {
			tmp = new XmlNode!R();
			tmp._docroot = this;
			node = tmp;
		}
		super();
	}


	/// This static opCall should be used when creating new XmlDocuments for use
	static auto opCall(R constring,bool preserveWS = false) {
		auto root = new XmlDocument!R;
		root.parse(constring,preserveWS);
		return root;
	}

	/// This function resets the node to a default state
	override void reset() {
		foreach(child;_children) {
			child.reset;
		}
		_children.length = 0;
	}

	void parse(R constring,bool preserveWS = false) {
		auto pointcpy = constring;
		try {
			addChildren(constring,preserveWS);
		} catch (XmlError e) {
			logline("Caught exception from input string:\n"~to!string(pointcpy)~"\n");
			throw e;
		}
	}

	/// Allow usage of the free list and allocation for XmlNodes if necessary.
	auto allocXmlNode() {
		XmlNode!R tmp;
		// use already allocated instances if available
		if (xmlNodes.length) {
			tmp = xmlNodes[$-1];
			xmlNodes.length = xmlNodes.length - 1;
		} else {
			// otherwise, allocate a new one and set it up properly
			tmp = new XmlNode!R();
			tmp._docroot = this;
		}
		return tmp;
	}

	/// Allow usage of the free list and allocation for CData nodes if necessary.
	auto allocCData() {
		CData!R tmp;
		// use already allocated instances if available
		if (cdataNodes.length) {
			tmp = cdataNodes[$-1];
			cdataNodes.length = cdataNodes.length - 1;
		} else {
			// otherwise, allocate a new one and set it up properly
			tmp = new CData!R();
			tmp._docroot = this;
		}
		return tmp;
	}

	/// Allow usage of the free list and allocation for XmlComments if necessary.
	auto allocXmlComment() {
		XmlComment!R tmp;
		// use already allocated instances if available
		if (xmlCommentNodes.length) {
			tmp = xmlCommentNodes[$-1];
			xmlCommentNodes.length = xmlCommentNodes.length - 1;
		} else {
			// otherwise, allocate a new one and set it up properly
			tmp = new XmlComment!R();
			tmp._docroot = this;
		}
		return tmp;
	}

	/// Allow usage of the free list and allocation for XmlPIs if necessary.
	auto allocXmlPI() {
		XmlPI!R tmp;
		// use already allocated instances if available
		if (xmlPINodes.length) {
			tmp = xmlPINodes[$-1];
			xmlPINodes.length = xmlPINodes.length - 1;
		} else {
			// otherwise, allocate a new one and set it up properly
			tmp = new XmlPI!R();
			tmp._docroot = this;
		}
		return tmp;
	}

	override bool opEquals(Object o) {
		auto cmp = cast(XmlDocument!R)o;
		if (cmp is null) {
			return false;
		}
		if (getChildren != cmp.getChildren) {
			return false;
		}
		return true;
	}
}


/// Encode characters such as &, <, >, etc. as their xml/html equivalents
auto xmlEncode(R)(R src) {
        src = replace(to!string(src), "&", "&amp;");
        src = replace(to!string(src), "<", "&lt;");
        src = replace(to!string(src), ">", "&gt;");
        src = replace(to!string(src), "\"", "&quot;");
        src = replace(to!string(src), "'", "&apos;");
        return src;
}

/// Convert xml-encoded special characters such as &amp;amp; back to &amp;.
auto xmlDecode(R)(R src) {
        src = replace(to!string(src), "&lt;",  "<");
        src = replace(to!string(src), "&gt;",  ">");
        src = replace(to!string(src), "&apos;", "'");
        src = replace(to!string(src), "&quot;",  "\"");
	// take care of decimal character entities
	src = regrep(to!string(src),"&#\\d{1,8};",(string m) {
		auto cnum = m[2..m.length-1];
		dchar dnum = cast(dchar)to!int(cnum);
		return quickUTF8(dnum);
	});
	// take care of hex character entities
	src = regrep(to!string(src),"&#[xX][0-9a-fA-F]{1,8};",(string m) {
		auto cnum = m[3..$-1];
		dchar dnum = hex2dchar(cnum);
		return quickUTF8(dnum);
	});
        src = replace(to!string(src), "&amp;", "&");
        return src;
}

// a quick dchar to utf8 conversion
private auto quickUTF8(dchar dachar) {
	char[]ret;
	foreach(char r;[dachar]) {
		ret ~= r;
	}
	return to!string(ret);
}

// convert a hex string to a raw dchar
private dchar hex2dchar(R)(R hex) {
	dchar res = 0;
	foreach(digit;hex) {
		res <<= 4;
		res |= toHVal(digit);
	}
	return res;
}

// convert a single hex digit to its raw value
private dchar toHVal(char digit) {
	if (digit >= '0' && digit <= '9') {
		return digit-'0';
	}
	if (digit >= 'a' && digit <= 'f') {
		return digit-'a'+10;
	}
	if (digit >= 'A' && digit <= 'F') {
		return digit-'A'+10;
	}
	return 0;
}


unittest {
	string xmlstring = "<message responseID=\"1234abcd\" text=\"weather 12345\" type=\"message\" order=\"5\"><flags>triggered</flags><flags>targeted</flags></message>";
	runTests(xmlstring);
	runTests(cast(custring)xmlstring);

	string xmlstring2 =
	`<table class="table1">
	<tr>         <th>URL </th><td><a href="path1/path2">Link 1.1</a></td></tr>
	<tr ab="two"><th>Head</th><td>Text 1.2</td></tr>
	<tr ab="4">  <th>Head</th><td>Text 1.3</td></tr>
	</table>
	<table class="table2">
	<tr>         <th>URL </th><td><a href="path1/path2">Link 2.1</a></td></tr>
	<tr ab="six"><th>Head</th><td>Text 2.2</td></tr>
	<tr ab="9">  <th>Head</th><td>Text 2.3</td></tr>
	</table>`;

	runTests2(xmlstring2);
	runTests2(cast(custring)xmlstring2);
}

version(XML_main) {
	void main(){}
}

version(unittest) {
	void runTests(R)(R xmlstring) {
		logline("Running "~R.stringof~" tests\n");
		auto xml = readDocument(xmlstring);
		xmlstring = xml.toXml;
 		// ensure that the string doesn't mutate after a second reading, it shouldn't
		assert((readDocument(xmlstring.save).toXml == xmlstring));

		logline("kxml.xml XPath test\n");
		auto searchlist = xml.parseXPath(to!R("message/flags"));
		assert(searchlist.length == 2 && equal(searchlist[0].getName, "flags"));
	
		logline("kxml.xml deep XPath test\n");
		searchlist = xml.parseXPath(to!R("//message//flags"));
		assert(searchlist.length == 2 && equal(searchlist[0].getName, "flags"));
	
 		logline("kxml.xml attribute match 'and' XPath test\n");
 		searchlist = xml.parseXPath(to!R("/message[@type=\"message\" and @responseID=\"1234abcd\"]/flags"));
		assert(searchlist.length == 2 && equal(searchlist[0].getName, "flags"));
 		searchlist = xml.parseXPath(to!R("message[@type=\"toaster\"]/flags"));
 		assert(searchlist.length == 0);

 		logline("kxml.xml attribute match 'or' XPath test\n");
 		searchlist = xml.parseXPath(to!R("/message[@type=\"message\" or @responseID=\"134abcd\"]/flags"));
		assert(searchlist.length == 2 && equal(searchlist[0].getName, "flags"));
 		searchlist = xml.parseXPath(to!R("/message[@type=\"yarblemessage\" or @responseID=\"1234abcd\"]/flags"));
		assert(searchlist.length == 2 && equal(searchlist[0].getName, "flags"));

	
 		logline("kxml.xml XPath inequality test\n");
 		searchlist = xml.parseXPath(to!R("/message[@order<6]/flags"));
		assert(searchlist.length == 2 && equal(searchlist[0].getName, "flags"));
 		searchlist = xml.parseXPath(to!R("/message[@order>4]/flags"));
		assert(searchlist.length == 2 && equal(searchlist[0].getName, "flags"));
 		searchlist = xml.parseXPath(to!R("/message[@order>=5]/flags"));
		assert(searchlist.length == 2 && equal(searchlist[0].getName, "flags"));
 		searchlist = xml.parseXPath(to!R("/message[@order<=5]/flags"));
		assert(searchlist.length == 2 && equal(searchlist[0].getName, "flags"));
 		searchlist = xml.parseXPath(to!R("/message[@order!=1]/flags"));
		assert(searchlist.length == 2 && equal(searchlist[0].getName, "flags"));
 		searchlist = xml.parseXPath(to!R("/message[@order=5]/flags"));
		assert(searchlist.length == 2 && equal(searchlist[0].getName, "flags"));

		logline("kxml.xml XPath CData tests\n");
		searchlist = xml.parseXPath(to!R(`//@text`));
		assert(searchlist.length == 1 && equal(searchlist[0].getCData, "weather 12345"));
		searchlist = xml.parseXPath(to!R(`/message[flags="triggered" and flags="targeted"]/@order`));
		assert(searchlist.length == 1 && equal(searchlist[0].getCData, "5"));
		searchlist = xml.parseXPath(to!R(`/message[@order<6 and flags="triggered"]/flags`));
		assert(searchlist.length == 2 && equal(searchlist[0].getName, "flags"));
		searchlist = xml.parseXPath(to!R(`/message[@order<6 and flags="fail"]/flags`));
		assert(searchlist.length == 0);


		/*logline("kxml.xml XPath subnode match test\n");
		searchlist = xml.parseXPath("/message[flags@tweak]");
		assert(searchlist.length == 2 && searchlist[0].getName == "flags");*/
	}

	void runTests2(R)(R xmlstring) {
		logline("Running More tests\n");
		auto xml = readDocument(xmlstring);

		logline("kxml.xml XPath no-match tests\n");
		auto
		searchlist = xml.parseXPath(to!R(`//ab`));
		assert(searchlist.length == 0);
		searchlist = xml.parseXPath(to!R(`//ab=9`));		// Should this throw?
		assert(searchlist.length == 0);
		searchlist = xml.parseXPath(to!R(`//td="Text2.2"`));	// Should this throw?
		assert(searchlist.length == 0);
		searchlist = xml.parseXPath(to!R(`//tr[ab<=7]/td`));
		assert(searchlist.length == 0);

		logline("kxml.xml XPath attr tests\n");
		searchlist = xml.parseXPath(to!R(`//@ab`));
		assert(searchlist.length == 4);
		searchlist = xml.parseXPath(to!R(`//@ab<=7`));
		assert(searchlist.length == 1);
		searchlist = xml.parseXPath(to!R(`//table[@class!="table2"]//@ab`));
		assert(searchlist.length == 2);
//		searchlist = xml.parseXPath(to!R(`//@class!="table2"//@ab`));	// Should this work?
//		assert(searchlist.length == 2);

		logline("kxml.xml XPath predicate tests\n");
		searchlist = xml.parseXPath(to!R(`//tr[@ab<=7]/td`));
		assert(searchlist.length == 1 && equal(searchlist[0].getCData, "Text 1.3"));
		searchlist = xml.parseXPath(to!R(`//tr[@ab>=9 and th="Head"]/td`));
		assert(searchlist.length == 1 && equal(searchlist[0].getCData, "Text 2.3"));
	}

	struct custring {
		string data;
		void opAssign(custring assgn) {data = assgn.data;}
		// XXX should't need it?
		void opAssign(string assgn) {data = assgn;}

		// XXX does this have something in ranges?
		custring opBinary(string op)(custring b) {
			static if (op == "~") {
				custring concat;
				concat.data = data~b.data;
				return concat;
			} else static assert(0, "Operator "~op~" not implemented");
		}

		// Start hasLength functions
		@property {
			size_t length() const {return data.length;}
			void length(size_t len) {data.length = len;}
		}
		// End hasLength functions

		// Start InputRange functions
		bool empty() const {return data.empty();}
		dchar front() const {return data.front();}
		void popFront() {data.popFront();}
		// End InputRange functions

		// Start ForwardRange functions (implies InputRange)
		custring save() {return this;}
		// End ForwardRange functions

		// Start BidirectionalRange functions (implies ForwardRange)
		dchar back() const {return data.back();}
		void popBack() {data.popBack();}
		// End BidirectionalRange functions

		// Start hashing functions (implicitly available and so need no compile-time test)
		bool opEquals(custring b) {return data == b.data;}
		const hash_t toHash() {
			hash_t hash;
			foreach (char c; data) {
				hash = (hash * 9) + c;
			}
			return hash;
		}
		const int opCmp(ref const custring c) {
			return c.data != data;
		}
		// End hashing functions
	}
}

